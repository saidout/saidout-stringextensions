using NUnit.Framework;

namespace SaidOut.StringExtensions.Tests
{
    public class Base64Extension_Tests
    {

        [TestCase(new byte[] { 0x00, 0x10, 0x83, 0x10, 0x51, 0x87, 0x20, 0x92, 0x8B, 0x30, 0xD3, 0x8F, 0x41, 0x14, 0x93, 0x51, 0x55, 0x97, 0x61, 0x96, 0x9B, 0x71, 0xD7, 0x9F, 0x82, 0x18, 0xA3, 0x92, 0x59, 0xA7, 0xA2, 0x9A, 0xAB, 0xB2, 0xDB, 0xAF, 0xC3, 0x1C, 0xB3, 0xD3, 0x5D, 0xB7, 0xE3, 0x9E, 0xBB, 0xF3, 0xDF, 0xBF }, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")]
        [TestCase(new byte[] { 0xFF, 0xEF, 0x7C, 0xEF, 0xAE, 0x78, 0xDF, 0x6D, 0x74, 0xCF, 0x2C, 0x70, 0xBE, 0xEB, 0x6C, 0xAE, 0xAA, 0x68, 0x9E, 0x69, 0x64, 0x8E, 0x28, 0x60, 0x7D, 0xE7, 0x5C, 0x6D, 0xA6, 0x58, 0x5D, 0x65, 0x54, 0x4D, 0x24, 0x50, 0x3C, 0xE3, 0x4C, 0x2C, 0xA2, 0x48, 0x1C, 0x61, 0x44, 0x0C, 0x20, 0x40 }, "/+9876543210zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA")]
        [TestCase(new byte[] { 0x12 }, "Eg==")]
        [TestCase(new byte[] { 0x12, 0x34 }, "EjQ=")]
        [TestCase(new byte[] { 0x12, 0x34, 0x56 }, "EjRW")]
        [TestCase(new byte[] { 0x12, 0x34, 0x56, 0x78 }, "EjRWeA==")]
        [TestCase(new byte[] { 0x12, 0x34, 0x56, 0x78, 0x9a }, "EjRWeJo=")]
        [TestCase(new byte[] { 0xF3, 0xF6, 0xE9, 0xE7, 0xBF, 0xB4 }, "8/bp57+0")]
        public void ToBase64String_Value_ReturnExpected(byte[] value, string expected)
        {
            var actual = value.ToBase64String();

            Assert.AreEqual(expected, actual);
        }


        [Test]
        public void ToBase64String_ValueIsNull_ReturnEmptyString()
        {
            var actual = ((byte[]?) null).ToBase64String();

            Assert.AreEqual(string.Empty, actual);
        }


        [TestCase("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", new byte[] { 0x00, 0x10, 0x83, 0x10, 0x51, 0x87, 0x20, 0x92, 0x8B, 0x30, 0xD3, 0x8F, 0x41, 0x14, 0x93, 0x51, 0x55, 0x97, 0x61, 0x96, 0x9B, 0x71, 0xD7, 0x9F, 0x82, 0x18, 0xA3, 0x92, 0x59, 0xA7, 0xA2, 0x9A, 0xAB, 0xB2, 0xDB, 0xAF, 0xC3, 0x1C, 0xB3, 0xD3, 0x5D, 0xB7, 0xE3, 0x9E, 0xBB, 0xF3, 0xDF, 0xBF })]
        [TestCase("/+9876543210zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA", new byte[] { 0xFF, 0xEF, 0x7C, 0xEF, 0xAE, 0x78, 0xDF, 0x6D, 0x74, 0xCF, 0x2C, 0x70, 0xBE, 0xEB, 0x6C, 0xAE, 0xAA, 0x68, 0x9E, 0x69, 0x64, 0x8E, 0x28, 0x60, 0x7D, 0xE7, 0x5C, 0x6D, 0xA6, 0x58, 0x5D, 0x65, 0x54, 0x4D, 0x24, 0x50, 0x3C, 0xE3, 0x4C, 0x2C, 0xA2, 0x48, 0x1C, 0x61, 0x44, 0x0C, 0x20, 0x40 })]
        [TestCase("Eg==", new byte[] { 0x12 })]
        [TestCase("EjQ=", new byte[] { 0x12, 0x34 })]
        [TestCase("EjRW", new byte[] { 0x12, 0x34, 0x56 })]
        [TestCase("EjRWeA==", new byte[] { 0x12, 0x34, 0x56, 0x78 })]
        [TestCase("EjRWeJo=", new byte[] { 0x12, 0x34, 0x56, 0x78, 0x9a })]
        [TestCase("8/bp57+0", new byte[] { 0xF3, 0xF6, 0xE9, 0xE7, 0xBF, 0xB4 })]
        public void FromBase64StringToByteArray_Value_ReturnExpected(string value, byte[] expected)
        {
            var actual = value.FromBase64StringToByteArray();

            Assert.AreEqual(expected, actual);
        }


        [Test]
        public void FromBase64StringToByteArray_ValueIsNull_ReturnEmptyArray()
        {
            var actual = ((string?) null).FromBase64StringToByteArray();

            Assert.AreEqual(new byte[0], actual);
        }


        [TestCase("abc-")]
        [TestCase("abc_")]
        [TestCase("ba?")]
        public void FromBase64StringToByteArrayWithShouldReturnNullIfConversionFailedSetToFalse_ValueContainsNonBase64UrlCharacters_ThrowsArgumentException(string value)
        {
            var ex = Assert.Throws<ArgumentException>(() => value.FromBase64StringToByteArray(false));
            Assert.That(ex?.ParamName, Is.EqualTo("value"), nameof(ex.ParamName));
            Assert.That(ex?.Message, Does.Contain("Base-64 string").And.Contains("illegal character"), nameof(ex.Message));
        }


        [TestCase("abc")]
        public void FromBase64StringToByteArrayWithShouldReturnNullIfConversionFailedSetToFalse_InvalidBase64Length_ThrowsArgumentException(string value)
        {
            var ex = Assert.Throws<ArgumentException>(() => value.FromBase64StringToByteArray(false));
            Assert.That(ex?.ParamName, Is.EqualTo("value"), nameof(ex.ParamName));
            Assert.That(ex?.Message, Does.Contain("Base-64 string"), nameof(ex.Message));
        }


        [TestCase("abc-")]
        [TestCase("abc_")]
        [TestCase("ba?")]
        [TestCase("abc")]
        public void FromBase64StringToByteArrayWithShouldReturnNullIfConversionFailedSetToTrue_InvalidBase64_ReturnNull(string value)
        {
            var actual = value.FromBase64StringToByteArray();

            Assert.That(actual, Is.Null);
        }


        [TestCase(new byte[] { 0x00, 0x10, 0x83, 0x10, 0x51, 0x87, 0x20, 0x92, 0x8B, 0x30, 0xD3, 0x8F, 0x41, 0x14, 0x93, 0x51, 0x55, 0x97, 0x61, 0x96, 0x9B, 0x71, 0xD7, 0x9F, 0x82, 0x18, 0xA3, 0x92, 0x59, 0xA7, 0xA2, 0x9A, 0xAB, 0xB2, 0xDB, 0xAF, 0xC3, 0x1C, 0xB3, 0xD3, 0x5D, 0xB7, 0xE3, 0x9E, 0xBB, 0xF3, 0xDF, 0xBF }, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_")]
        [TestCase(new byte[] { 0xFF, 0xEF, 0x7C, 0xEF, 0xAE, 0x78, 0xDF, 0x6D, 0x74, 0xCF, 0x2C, 0x70, 0xBE, 0xEB, 0x6C, 0xAE, 0xAA, 0x68, 0x9E, 0x69, 0x64, 0x8E, 0x28, 0x60, 0x7D, 0xE7, 0x5C, 0x6D, 0xA6, 0x58, 0x5D, 0x65, 0x54, 0x4D, 0x24, 0x50, 0x3C, 0xE3, 0x4C, 0x2C, 0xA2, 0x48, 0x1C, 0x61, 0x44, 0x0C, 0x20, 0x40 }, "_-9876543210zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA")]
        [TestCase(new byte[] { 0x12 }, "Eg")]
        [TestCase(new byte[] { 0x12, 0x34 }, "EjQ")]
        [TestCase(new byte[] { 0x12, 0x34, 0x56 }, "EjRW")]
        [TestCase(new byte[] { 0x12, 0x34, 0x56, 0x78 }, "EjRWeA")]
        [TestCase(new byte[] { 0x12, 0x34, 0x56, 0x78, 0x9a }, "EjRWeJo")]
        [TestCase(new byte[] { 0xF3, 0xF6, 0xE9, 0xE7, 0xBF, 0xB4 }, "8_bp57-0")]
        public void ToBase64UrlStringWithPaddingRemoved_Value_ReturnExpected(byte[] value, string expected)
        {
            var actual = value.ToBase64UrlString();

            Assert.AreEqual(expected, actual);
        }


        [TestCase(new byte[] { 0x00, 0x10, 0x83, 0x10, 0x51, 0x87, 0x20, 0x92, 0x8B, 0x30, 0xD3, 0x8F, 0x41, 0x14, 0x93, 0x51, 0x55, 0x97, 0x61, 0x96, 0x9B, 0x71, 0xD7, 0x9F, 0x82, 0x18, 0xA3, 0x92, 0x59, 0xA7, 0xA2, 0x9A, 0xAB, 0xB2, 0xDB, 0xAF, 0xC3, 0x1C, 0xB3, 0xD3, 0x5D, 0xB7, 0xE3, 0x9E, 0xBB, 0xF3, 0xDF, 0xBF }, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_")]
        [TestCase(new byte[] { 0xFF, 0xEF, 0x7C, 0xEF, 0xAE, 0x78, 0xDF, 0x6D, 0x74, 0xCF, 0x2C, 0x70, 0xBE, 0xEB, 0x6C, 0xAE, 0xAA, 0x68, 0x9E, 0x69, 0x64, 0x8E, 0x28, 0x60, 0x7D, 0xE7, 0x5C, 0x6D, 0xA6, 0x58, 0x5D, 0x65, 0x54, 0x4D, 0x24, 0x50, 0x3C, 0xE3, 0x4C, 0x2C, 0xA2, 0x48, 0x1C, 0x61, 0x44, 0x0C, 0x20, 0x40 }, "_-9876543210zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA")]
        [TestCase(new byte[] { 0x12 }, "Eg%3D%3D")]
        [TestCase(new byte[] { 0x12, 0x34 }, "EjQ%3D")]
        [TestCase(new byte[] { 0x12, 0x34, 0x56 }, "EjRW")]
        [TestCase(new byte[] { 0x12, 0x34, 0x56, 0x78 }, "EjRWeA%3D%3D")]
        [TestCase(new byte[] { 0x12, 0x34, 0x56, 0x78, 0x9a }, "EjRWeJo%3D")]
        [TestCase(new byte[] { 0xF3, 0xF6, 0xE9, 0xE7, 0xBF, 0xB4 }, "8_bp57-0")]
        public void ToBase64UrlStringWithPadding_Value_ReturnExpected(byte[] value, string expected)
        {
            var actual = value.ToBase64UrlString(false);

            Assert.AreEqual(expected, actual);
        }


        [Test]
        public void ToBase64UrlString_ValueIsNull_ReturnEmptyString()
        {
            var actual = ((byte[]?) null).ToBase64UrlString();

            Assert.AreEqual(string.Empty, actual);
        }


        [TestCase("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", new byte[] { 0x00, 0x10, 0x83, 0x10, 0x51, 0x87, 0x20, 0x92, 0x8B, 0x30, 0xD3, 0x8F, 0x41, 0x14, 0x93, 0x51, 0x55, 0x97, 0x61, 0x96, 0x9B, 0x71, 0xD7, 0x9F, 0x82, 0x18, 0xA3, 0x92, 0x59, 0xA7, 0xA2, 0x9A, 0xAB, 0xB2, 0xDB, 0xAF, 0xC3, 0x1C, 0xB3, 0xD3, 0x5D, 0xB7, 0xE3, 0x9E, 0xBB, 0xF3, 0xDF, 0xBF })]
        [TestCase("_-9876543210zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA", new byte[] { 0xFF, 0xEF, 0x7C, 0xEF, 0xAE, 0x78, 0xDF, 0x6D, 0x74, 0xCF, 0x2C, 0x70, 0xBE, 0xEB, 0x6C, 0xAE, 0xAA, 0x68, 0x9E, 0x69, 0x64, 0x8E, 0x28, 0x60, 0x7D, 0xE7, 0x5C, 0x6D, 0xA6, 0x58, 0x5D, 0x65, 0x54, 0x4D, 0x24, 0x50, 0x3C, 0xE3, 0x4C, 0x2C, 0xA2, 0x48, 0x1C, 0x61, 0x44, 0x0C, 0x20, 0x40 })]
        [TestCase("Eg%3D%3D", new byte[] { 0x12 })]
        [TestCase("EjQ%3D", new byte[] { 0x12, 0x34 })]
        [TestCase("EjRW", new byte[] { 0x12, 0x34, 0x56 })]
        [TestCase("EjRWeA%3D%3D", new byte[] { 0x12, 0x34, 0x56, 0x78 })]
        [TestCase("EjRWeJo%3D", new byte[] { 0x12, 0x34, 0x56, 0x78, 0x9a })]
        [TestCase("8_bp57-0", new byte[] { 0xF3, 0xF6, 0xE9, 0xE7, 0xBF, 0xB4 })]
        [TestCase("Eg", new byte[] { 0x12 })]
        [TestCase("EjQ", new byte[] { 0x12, 0x34 })]
        [TestCase("EjRW", new byte[] { 0x12, 0x34, 0x56 })]
        [TestCase("EjRWeA", new byte[] { 0x12, 0x34, 0x56, 0x78 })]
        [TestCase("EjRWeJo", new byte[] { 0x12, 0x34, 0x56, 0x78, 0x9a })]
        public void FromBase64UrlStringToByteArray_Value_ReturnExpected(string value, byte[] expected)
        {
            var actual = value.FromBase64UrlStringToByteArray();

            Assert.AreEqual(expected, actual);
        }


        [TestCase]
        public void FromBase64UrlStringToByteArray_ValueIsNull_ReturnEmptyArray()
        {
            var actual = ((string?) null).FromBase64UrlStringToByteArray();

            Assert.AreEqual(new byte[0], actual);
        }


        [TestCase("abc+")]
        [TestCase("abc/")]
        [TestCase("ba?")]
        public void FromBase64UrlStringToByteArrayShouldReturnNullIfConversionFailedSetToFalse_ValueContainsNonBase64UrlCharacters_ThrowsArgumentException(string value)
        {
            var ex = Assert.Throws<ArgumentException>(() => value.FromBase64UrlStringToByteArray(false));
            Assert.That(ex?.ParamName, Is.EqualTo("value"), nameof(ex.ParamName));
            Assert.That(ex?.Message, Does.Contain("Base-64 url").And.Contains("illegal character"), nameof(ex.Message));
        }


        [TestCase("abc+")]
        [TestCase("abc/")]
        [TestCase("ba?")]
        public void FromBase64UrlStringToByteArrayWithShouldReturnNullIfConversionFailedSetToTrue_InvalidBase64_ReturnNull(string value)
        {
            var actual = value.FromBase64UrlStringToByteArray();

            Assert.That(actual, Is.Null);
        }
    }
}


//  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/  <->  0x00, 0x10, 0x83, 0x10, 0x51, 0x87, 0x20, 0x92, 0x8B, 0x30, 0xD3, 0x8F, 0x41, 0x14, 0x93, 0x51, 0x55, 0x97, 0x61, 0x96, 0x9B, 0x71, 0xD7, 0x9F, 0x82, 0x18, 0xA3, 0x92, 0x59, 0xA7, 0xA2, 0x9A, 0xAB, 0xB2, 0xDB, 0xAF, 0xC3, 0x1C, 0xB3, 0xD3, 0x5D, 0xB7, 0xE3, 0x9E, 0xBB, 0xF3, 0xDF, 0xBF
//  /+9876543210zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA  <->  0xFF, 0xEF, 0x7C, 0xEF, 0xAE, 0x78, 0xDF, 0x6D, 0x74, 0xCF, 0x2C, 0x70, 0xBE, 0xEB, 0x6C, 0xAE, 0xAA, 0x68, 0x9E, 0x69, 0x64, 0x8E, 0x28, 0x60, 0x7D, 0xE7, 0x5C, 0x6D, 0xA6, 0x58, 0x5D, 0x65, 0x54, 0x4D, 0x24, 0x50, 0x3C, 0xE3, 0x4C, 0x2C, 0xA2, 0x48, 0x1C, 0x61, 0x44, 0x0C, 0x20, 0x40
//  EjQ=      <->  0x01, 0x02, 0x03, 0x04
//  EjRQ==    <->  0x01, 0x02, 0x03, 0x04, 0x05
//  EjRW      <->  0x01, 0x02, 0x03, 0x04, 0x05, 0x06
//  EjRWc=    <->  0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
//  EjRWeA==  <->  0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
//  8/bp57+0  <->  0xF3, 0xF6, 0xE9, 0xE7, 0xBF, 0xB4


//Value Char
//  0 (000000) A | 16 (010000) Q | 32 (100000) g | 48 (110000) w
//  1 (000001) B | 17 (010001) R | 33 (100001) h | 49 (110001) x
//  2 (000010) C | 18 (010010) S | 34 (100010) i | 50 (110010) y
//  3 (000011) D | 19 (010011) T | 35 (100011) j | 51 (110011) z
//  4 (000100) E | 20 (010100) U | 36 (100100) k | 52 (110100) 0
//  5 (000101) F | 21 (010101) V | 37 (100101) l | 53 (110101) 1
//  6 (000110) G | 22 (010110) W | 38 (100110) m | 54 (110110) 2
//  7 (000111) H | 23 (010111) X | 39 (100111) n | 55 (110111) 3
//  8 (001000) I | 24 (011000) Y | 40 (101000) o | 56 (111000) 4
//  9 (001001) J | 25 (011001) Z | 41 (101001) p | 57 (111001) 5
// 10 (001010) K | 26 (011010) a | 42 (101010) q | 58 (111010) 6
// 11 (001011) L | 27 (011011) b | 43 (101011) r | 59 (111011) 7
// 12 (001100) M | 28 (011100) c | 44 (101100) s | 60 (111100) 8
// 13 (001101) N | 29 (011101) d | 45 (101101) t | 61 (111101) 9
// 14 (001110) O | 30 (011110) e | 46 (101110) u | 62 (111110) +
// 15 (001111) P | 31 (011111) f | 47 (101111) v | 63 (111111) /


//  0 (000000) A
//  1 (000001) B
//  2 (000010) C
//  3 (000011) D
//  4 (000100) E
//  5 (000101) F
//  6 (000110) G
//  7 (000111) H
//  8 (001000) I
//  9 (001001) J
// 10 (001010) K
// 11 (001011) L
// 12 (001100) M
// 13 (001101) N
// 14 (001110) O
// 15 (001111) P
// 16 (010000) Q
// 17 (010001) R
// 18 (010010) S
// 19 (010011) T
// 20 (010100) U
// 21 (010101) V
// 22 (010110) W
// 23 (010111) X
// 24 (011000) Y
// 25 (011001) Z
// 26 (011010) a
// 27 (011011) b
// 28 (011100) c
// 29 (011101) d
// 30 (011110) e
// 31 (011111) f
// 32 (100000) g
// 33 (100001) h
// 34 (100010) i
// 35 (100011) j
// 36 (100100) k
// 37 (100101) l
// 38 (100110) m
// 39 (100111) n
// 40 (101000) o
// 41 (101001) p
// 42 (101010) q
// 43 (101011) r
// 44 (101100) s
// 45 (101101) t
// 46 (101110) u
// 47 (101111) v
// 48 (110000) w
// 49 (110001) x
// 50 (110010) y
// 51 (110011) z
// 52 (110100) 0
// 53 (110101) 1
// 54 (110110) 2
// 55 (110111) 3
// 56 (111000) 4
// 57 (111001) 5
// 58 (111010) 6
// 59 (111011) 7
// 60 (111100) 8
// 61 (111101) 9
// 62 (111110) +
// 63 (111111) /



//  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/  
//  A-P:  0000 0000 0001 0000 1000 0011 0001 0000 0101 0001 1000 0111 0010 0000 1001 0010 1000 1011 0011 0000 1101 0011 1000 1111  = 0x00, 0x10, 0x83, 0x10, 0x51, 0x87, 0x20, 0x92, 0x8B, 0x30, 0xD3, 0x8F
//  Q-f:  0100 0001 0001 0100 1001 0011 0101 0001 0101 0101 1001 0111 0110 0001 1001 0110 1001 1011 0111 0001 1101 0111 1001 1111  = 0x41, 0x14, 0x93, 0x51, 0x55, 0x97, 0x61, 0x96, 0x9B, 0x71, 0xD7, 0x9F
//  g-v:  1000 0010 0001 1000 1010 0011 1001 0010 0101 1001 1010 0111 1010 0010 1001 1010 1010 1011 1011 0010 1101 1011 1010 1111  = 0x82, 0x18, 0xA3, 0x92, 0x59, 0xA7, 0xA2, 0x9A, 0xAB, 0xB2, 0xDB, 0xAF
//  w-/:  1100 0011 0001 1100 1011 0011 1101 0011 0101 1101 1011 0111 1110 0011 1001 1110 1011 1011 1111 0011 1101 1111 1011 1111  = 0xC3, 0x1C, 0xB3, 0xD3, 0x5D, 0xB7, 0xE3. 0x9E, 0xBB, 0xF3, 0xDF, 0xBF


//  /+9876543210zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
//  /-w:  1111 1111 1110 1111 0111 1100 1110 1111 1010 1110 0111 1000 1101 1111 0110 1101 0111 0100 1100 1111 0010 1100 0111 0000  = 0xFF, 0xEF, 0x7C, 0xEF, 0xAE, 0x78, 0xDF, 0x6D, 0x74, 0xCF, 0x2C, 0x70
//  v-g:  1011 1110 1110 1011 0110 1100 1010 1110 1010 1010 0110 1000 1001 1110 0110 1001 0110 0100 1000 1110 0010 1000 0110 0000  = 0xBE, 0xEB, 0x6C, 0xAE, 0xAA, 0x68, 0x9E, 0x69, 0x64, 0x8E, 0x28, 0x60
//  f-Q:  0111 1101 1110 0111 0101 1100 0110 1101 1010 0110 0101 1000 0101 1101 0110 0101 0101 0100 0100 1101 0010 0100 0101 0000  = 0x7D, 0xE7, 0x5C, 0x6D, 0xA6, 0x58, 0x5D, 0x65, 0x54, 0x4D, 0x24, 0x50
//  P-A:  0011 1100 1110 0011 0100 1100 0010 1100 1010 0010 0100 1000 0001 1100 0110 0001 0100 0100 0000 1100 0010 0000 0100 0000  = 0x3C, 0xE3, 0x4C, 0x2C, 0xA2, 0x48, 0x1C, 0x61, 0x44, 0x0C, 0x20, 0x40


//  1: 0x12                            <->  0001 0010                                          <->  000100 10xxxx                                     <->  Eg==
//  2: 0x12, 0x34                      <->  0001 0010 0011 0100                                <->  000100 100011 0100xx                              <->  EjQ=
//  3: 0x12, 0x34, 0x56                <->  0001 0010 0011 0100 0101 0110                      <->  000100 100011 010001 010110                       <->  EjRW
//  4: 0x12, 0x34, 0x56, 0x78          <->  0001 0010 0011 0100 0101 0110 0111 1000            <->  000100 100011 010001 010110 011110 00xxxx         <->  EjRWeA==
//  5: 0x12, 0x34, 0x56, 0x78, 0x9A    <->  0001 0010 0011 0100 0101 0110 0111 1000 1001 1010  <->  000100 100011 010001 010110 011110 001001 1010xx  <->  EjRWeJo=


//  8/bp57+0  <->  60, 63, 27, 41, 57, 59, 62, 52  <->  1111 0011 1111 0110 1110 1001 1110 0111 1011 1111 1011 0100  <->  0xF3, 0xF6, 0xE9, 0xE7, 0xBF, 0xB4